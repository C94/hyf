#MySQL数据库优化

## 数据库优化分类
* 硬件 [取决于公司是否任性]
* 网络 [取决于公司是否任性]
* 软件 

> 软件再分为表设计，SQL语句优化与索引，配置文件参数，体系结构等方面优化

###表设计优化
合理的数据库优化可以使数据库占用更小的磁盘空间，而且查询速度更快。

* 将字段很多的表分解成多个表
> 对于使用频率不高的字段可以分离出来形成新表，因为当查询的时候，如果一个表数据量很大，因使用频率低的字段存在而变慢

* 增加适当的冗余字段
> 有时候在设计数据库时尽量遵守范式理论，尽可能减少冗余字段，但是合理的加入冗余字段，会提高查询速度，以空间换取时间

###字段类型的选择

> 原则：选取字段类型，一般是保小不保大，能用占用字节少的字段就不用大字段

#####数字类型

1. tinyint类型最大存储是255。
2. int(11)与int(21)的存储空间与存储范围是一样的。
3. 区别是：如果你选择是int(11)，那么你存放了一个1，那么结果是1前面有10个0，int(21)前面有20个零

#####字符串类型

1. char存储定长，容易造成空间浪费，char数据类型存储大小最大为255字符。
2. varchar存储变长，节省存储空间,varchar需要一位来存储长度。varchar是使用多少，就使用多少空间。所以通常都是选择varchar。
3. char是一种重视时间的存储方式，而varchar则是重视空间的存储方式。

* 字符与字节的关系

	如果是utf8字符集，因为utf8存放中文占用三个字节大小，所以存放两个中文需要6个字节大小。

	一个英语字母无论什么情况下都是占用一个字节的，所以varchar(6)就可以存放github这个英语单词了

#####时间类型
* date

    date三个字节，精确年月日
* time 

	time三个字节，只能存小时分钟，精确到小时分钟秒
* datetime
   
    datetime八字节，可以存储年月日时分秒
*timestamp
	timestamp四字节，可以存储年月日时分秒

##

### MySQL常用表引擎
* InnoDB
* MyISAM

#### InnoDB与MyISAM区别
1. 事务处理支持

	InnoDB是支持事务，MyISAM不支持事务
2. 查询速度

	一般认为MyISAM查询速度快，小项目可以使用MyISAM
3. 锁机制

    InnoDB支持行锁，表锁；MyISAM只有表锁
4. 文件存储方式

	MyISAM产生三个文件，.frm是存放表定义，MYD存放数据，MYI存放表的索引
	InnoDB的数据与索引一般是一起存放
5. 数据安全性

	InnoDB表比MyISAM表更安全，因为InnoDB具有崩溃恢复能力。

### 应该选择哪种表引擎
1. 如果你的mysql版本是5.6以后的都应该选择InnoDb
2. 如果你的mysql版本是5.6以前，如果这个表的查询频繁高，应该选择MyISAM.如果这个表的写操作频繁，应该选择InnoDb
	
### 采用合适的锁机制
* MySQL的锁有以下几种形式：
   * 表级锁：开销小，加锁快，不会出现死锁；锁定粒度大，发生锁冲突的概率高，并发度最低。MyISAM属于这类型。
   * 行级锁：开销大，加锁慢，会出现死锁；锁定粒度小，发生锁冲突的概率小，并发度最高。InnoDB就是行锁。
   
MyISAM：
> 读 =》 表锁 =》 读锁：不会阻塞其他的读，但是阻塞写
> 写 =》 表锁 =》 写锁：阻塞写，读

### 行锁的特点
> InnoDB存储引擎是通过索引上的索引项加锁起来，这就意味着：只有通过索引操作数据，InnoDB才会使用行锁。否则，InnoDB将使用表锁。

### SQL语句优化建议
* 避免使用子查询，可以用left join表连接替换
* limit分页优化
* 避免使用 \* 只查询需要的字段
* 多使用limit，减少数据传输
* 可以使用冗余来减少联表查询
* 在条件where后面的字段添加索引，并且合理使用索引

## 索引
分类：主键索引、唯一索引、普通索引、全文索引

### 合理使用索引
适当的索引对应用的性能来说相当重要，而且也建议在MySQL中使用索引，它的速度是很快的。

但是索引也是有成本的。<span style="color:red">每次向表中写入时，如果带有一个或多个索引，那么MySQL也要更新各个索引。索引还增加了数据库的规模，也就是说索引也是占据空间的。</span>

只有当某列被用于where子句时，才能享受索引性能提升的好处。如果不使用索引，它就没有价值，而且会带来维护上的开销。

### 索引常见用法
* 依据where查询条件建立索引

	select a,b from tab a where c = ? //应该给c建立索引
* 使用联合索引，而不是多个单列索引

	select * from tab where a = ? and b =?
	//给(a,b)建立联合索引，而不是分别给a,b建立索引
	alter table tab add index in_ab(a,b)

* 联合索引中索引字段的顺序根据区分度排，区分度大的放在前面

	//(name,sex);//将name放前面，因为name的区分度更大。因为sex只有0 1 2 这个三个值。

* 合理创建联合索引，避免冗余
	
		//(a),(a,b),(a,b,c)只要给(a,b,c)建立索引就行
* order by 、group by 、 distrinct字段添加索引

#### 用不到索引的情况（避免）

* 字段使用函数，将不能使用索引
* 用数字当字符类型，数字一定要加要引号

	select * from user where name = 123 //这SQL语句用不到name索引
		
	select * from user where name = '123' //这样写才会用到name字段上的索引
* 在使用like关键字进行查询的语句中，如果匹配字符串的第一个字符"%" , 索引不会起作用

	//用不到索引的		
	desc select *  from t where name like "%j%"\G;

	//用到索引
	desc select *  from t where name like "j%"\G;

* 联合索引，只有查询条件中使用了这些字段中第一个字段时，索引才会被使用

* 使用OR关键字的查询语句
	* 查询语句的查询条件中只有OR关键字，且OR前后的两个条件中的列都是索引时，查询中才使用索引。否则查询将不使用索引。
* order by 的字段混合使用asc和desc用不到索引
 
* where 子句使用的字段和order by 的字段不一致

	select * from user where name = 'jack' order by id;
* 对不同关键字使用order by 排序

		select * from user order by name,id;
